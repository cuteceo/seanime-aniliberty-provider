{
  "id": "animekai",
  "name": "AnimeKai",
  "description": "AnimeKai is an online streaming provider for subbed/dubbes animes in English",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeKai/manifest.json",
  "version": "1.0.4",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\"/>\n\nclass Provider {\n  api = \"https://animekai.to\";\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Server 1\", \"Server 2\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    console.log(\"Normalized Query: \" + normalizedQuery);\n\n    const url = `${this.api}/browser?keyword=${encodeURIComponent(\n      normalizedQuery\n    )}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const animes: SearchResult[] = [];\n      $(\"div.aitem-wrapper>div.aitem\").each((_, elem) => {\n        const id = elem.find(\"a.poster\").attr(\"href\")?.slice(1) ?? \"\";\n        const title = elem.find(\"a.title\").attr(\"title\") ?? \"\";\n        const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n        const url = `${this.api}/${id.slice(1)}`;\n\n        const anime: SearchResult = {\n          id: `${id}?dub=${query['dub']}`,\n          url: url,\n          title: title,\n          subOrDub: subOrDub,\n        };\n\n        animes.push(anime);\n      });\n\n      return animes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n\n    const url = `${this.api}/${id.split('?dub')[0]}`;\n    const rateBoxIdRegex = /<div class=\"rate-box\"[^>]*data-id=\"([^\"]+)\"/;\n    try {\n      let data: any = await this._makeRequest(url);\n      const idMatch = data.match(rateBoxIdRegex);\n      const aniId = idMatch ? idMatch[1] : null;\n      const KAICODEX:any = await loadKaiCodex();\n      \n\n      const urlFetchToken = KAICODEX.enc(aniId);\n\n      const fetchUrlListApi = `${this.api}/ajax/episodes/list?ani_id=${aniId}&_=${urlFetchToken}`;\n      const responseTextListApi = await this._makeRequest(fetchUrlListApi);\n      data = await JSON.parse(responseTextListApi);\n      // Evaluate the Kaicodex script to make KAICODEX available\n\n      const episodes: EpisodeDetails[] = [];\n\n      const $ = LoadDoc(data.result);\n      $('ul.range>li>a').each((_, elem) => {\n        const title = elem.find('span').text().replace(/\\s/g, ' ');\n        const number = parseInt(elem.attr('num')!, 10)\n        const token = elem.attr('token');\n        const tokenEncoded = KAICODEX.enc(token);\n        const episodeUrl = `https://animekai.to/ajax/links/list?token=${token}&_=${tokenEncoded}`;\n\n        episodes.push({\n          id: token ?? \"\",\n          number: number,\n          title: title,\n          url: `${episodeUrl}?dub=${id.split('?dub=')[1]}`\n        });\n      })\n\n      return episodes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(\n    episode: EpisodeDetails,\n    _server: string\n  ): Promise<EpisodeServer> {\n    let server = \"Server 1\";\n    if (_server !== \"default\") server = _server;\n\n    const episodeUrl = episode.url.replace('\\u0026', '&').split('?dub')[0];\n    const dubRequested = episode.url.split('?dub=')[1];\n\n    try {\n      const responseText = await this._makeRequest(episodeUrl);\n\n      const cleanedHtml = cleanJsonHtml(responseText);\n      const subRegex = /<div class=\"server-items lang-group\" data-id=\"sub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n      const softsubRegex = /<div class=\"server-items lang-group\" data-id=\"softsub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n      const dubRegex = /<div class=\"server-items lang-group\" data-id=\"dub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n\n      const subMatch = subRegex.exec(cleanedHtml);\n      const softsubMatch = softsubRegex.exec(cleanedHtml);\n      const dubMatch = dubRegex.exec(cleanedHtml);\n\n      const sub = subMatch ? subMatch[1].trim() : \"\";\n      const softsub = softsubMatch ? softsubMatch[1].trim() : \"\";\n      const dub = dubMatch ? dubMatch[1].trim() : \"\";\n\n      let dataLid = \"\";\n      let fetchUrlServerApi: any = \"\";\n      let KaiMegaUrlJson: any = \"\";\n      let megaELinkJson: any = \"\"\n      let megaEmbeddedUrl: any = \"\";\n      let megaMediaUrl: any = \"\";\n      let streamUrlJson: any = \"\";\n      let streamUrl: any = \"\";\n      let serverSpanRegex: any = \"\";\n\n      // Find server 1 span and extract data-lid\n      if (server == \"Server 1\")\n        serverSpanRegex = /<span class=\"server\"[^>]*data-lid=\"([^\"]+)\"[^>]*>Server 1<\\/span>/;\n      else\n        serverSpanRegex = /<span class=\"server\"[^>]*data-lid=\"([^\"]+)\"[^>]*>Server 2<\\/span>/;\n\n      const serverMatch = dubRequested === 'true' ? serverSpanRegex.exec(dub) : serverSpanRegex.exec(sub);\n\n      if (serverMatch && serverMatch[1]) {\n        dataLid = serverMatch[1];\n        const KAICODEX:any = await loadKaiCodex();\n\n        let dataLidToken: any = KAICODEX.enc(dataLid);\n\n        fetchUrlServerApi = `https://animekai.to/ajax/links/view?id=${dataLid}&_=${dataLidToken}`;\n\n        const responseTextServerApi = await this._makeRequest(fetchUrlServerApi);\n        const dataServerApi = await JSON.parse(responseTextServerApi);\n\n        KaiMegaUrlJson = KAICODEX.dec(dataServerApi.result);\n        megaELinkJson = JSON.parse(KaiMegaUrlJson);\n        megaEmbeddedUrl = megaELinkJson.url;\n        megaMediaUrl = megaEmbeddedUrl.replace(\"/e/\", \"/media/\");\n\n        // Fetch the media url\n        const mediaText = await this._makeRequest(megaMediaUrl);\n        const mediaJson = await JSON.parse(mediaText);\n\n        //console.log(mediaJson);\n\n        streamUrlJson = mediaJson.result;\n        streamUrlJson = KAICODEX.decMega(streamUrlJson);\n        const parsedStreamData = JSON.parse(streamUrlJson);\n\n        if (parsedStreamData && parsedStreamData.sources && parsedStreamData.sources.length > 0) {\n          streamUrl = parsedStreamData.sources[0].file;\n        } else {\n          console.log('No stream sources found in the response' + parsedStreamData);\n        }\n      }\n\n      if (streamUrl == \"\") {\n        throw new Error(\"Unable to find a valid source\")\n      }\n\n      const streams = await fetch(streamUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36\",\n          \"DNT\": \"1\"\n        }\n      });\n\n      //Regex to extract all the resolutions and url related to the resolutions available\n      const regex = /#EXT-X-STREAM-INF:BANDWIDTH=\\d+,RESOLUTION=(\\d+x\\d+)\\s*(.*)/g;\n      const videoSources: VideoSource[] = [];\n\n      let resolutionMatch;\n\n      while ((resolutionMatch = regex.exec(await streams.text())) !== null) {\n\n        let url = \"\";\n\n        if (resolutionMatch[2].includes(\"list\")) {\n          url = `${streamUrl.split(',')[0]}/${resolutionMatch[2]}`;\n        }\n        else {\n          url = `${streamUrl.split('/list')[0]}/${resolutionMatch[2]}`\n        }\n\n        videoSources.push({\n          quality: resolutionMatch[1].split('x')[1] + 'p', // 1920x1080 -> 1080p\n          subtitles: [], //Subs are already integrated in the video source\n          type: 'm3u8', //Standard type for AnimeKai\n          url: url\n        });\n      }\n\n      const episodeServer: EpisodeServer = {\n        server: server,\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0'\n        },\n        videoSources: [...videoSources]\n      };\n\n      return episodeServer\n\n    }\n    catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  normalizeQuery(query: string): string {\n    let normalizedQuery = query\n      .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, \"$1\") //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n      .replace(/\\s+/g, \" \") //Replaces 1+ whitespaces with 1 whitespace\n      .replace(/(\\d+)\\s*Season/i, \"$1\") //Removes season and keeps the number before the Season word\n      .replace(/Season\\s*(\\d+)/i, \"$1\") //Removes season and keeps the number after the Season word\n      .trim();\n\n    return normalizedQuery;\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        \"DNT\": \"1\",\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0\",\n        Cookie: \"__ddg1_=;__ddg2_=;\",\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    const body = await response.text();\n    return body;\n  }\n\n  isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n    const sub = elem.find(\"span.sub\").text();\n    const dub = elem.find(\"span.dub\").text();\n\n    if (sub != \"\" && dub != \"\") {\n      return \"both\";\n    }\n    if (sub != \"\") {\n      return \"sub\";\n    }\n\n    return \"dub\";\n  }\n}\n\n//Dinamically getting the KAICODEX script from the repository\nasync function loadKaiCodex() {\n  const response = await fetch('https://raw.githubusercontent.com/amarullz/kaicodex/refs/heads/main/generated/kai_codex.js');\n  const code = await response.text();\n\n  const sandbox: Record<string, any> = {};\n\n  const KAICODEX = new Function('sandbox', `\n    const exports = {};\n    const module = { exports };\n    let result;\n    (function() {\n      ${code}\n      result = KAICODEX;\n    })();\n    return result;\n  `)();\n\n  return KAICODEX;\n}\n\nfunction btoa(input: any) {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  let str = String(input);\n  let output = '';\n\n  for (let block = 0, charCode, i = 0, map = chars;\n    str.charAt(i | 0) || (map = '=', i % 1);\n    output += map.charAt(63 & (block >> (8 - (i % 1) * 8)))) {\n    charCode = str.charCodeAt(i += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new Error(\"btoa failed: The string contains characters outside of the Latin1 range.\");\n    }\n    block = (block << 8) | charCode;\n  }\n\n  return output;\n}\n\nfunction atob(input: any) {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  let str = String(input).replace(/=+$/, '');\n  let output = '';\n\n  if (str.length % 4 == 1) {\n    throw new Error(\"atob failed: The input is not correctly encoded.\");\n  }\n\n  for (let bc = 0, bs: any, buffer, i = 0;\n    (buffer = str.charAt(i++));\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4)\n      ? output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))\n      : 0) {\n    buffer = chars.indexOf(buffer);\n  }\n\n  return output;\n}\n\nfunction cleanHtmlSymbols(string: string) {\n  if (!string) return \"\";\n\n  return string\n    .replace(/&#8217;/g, \"'\")\n    .replace(/&#8211;/g, \"-\")\n    .replace(/&#[0-9]+;/g, \"\")\n    .replace(/\\r?\\n|\\r/g, \" \")  // Replace any type of newline with a space\n    .replace(/\\s+/g, \" \")       // Replace multiple spaces with a single space\n    .trim();                    // Remove leading/trailing whitespace\n}\n\nfunction cleanJsonHtml(jsonHtml: string) {\n  if (!jsonHtml) return \"\";\n\n  return jsonHtml\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\'/g, \"'\")\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\t/g, '\\t')\n    .replace(/\\\\r/g, '\\r');\n}\n\n\n"
}