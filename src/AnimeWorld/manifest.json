{
  "id": "animeworld",
  "name": "AnimeWorld",
  "description": "Extension for AnimeWorld, an online streaming provider for subbed/dubbes animes in Italian",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeWorld/manifest.json",
  "version": "1.0.3",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path='./online-streaming-provider.d.ts' />\n/// <reference path='./doc.d.ts' />\n\nclass Provider {\n  api: string = 'https://www.animeworld.ac';\n  threshold: number = 0.7;\n  getSettings(): Settings {\n    return {\n      episodeServers: ['AnimeWorld Server'],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query['query']);\n    console.log('Normalized Query: ' + normalizedQuery);\n\n    //AniList API Call\n    let aniListData:AniListAnimeDetails = await getAniListMangaDetails(query['query']);\n    const aniListTitlesAndSynonyms = [...aniListData.title, ...aniListData.synonyms];\n\n    let url = query['dub'] ? `${this.api}/filter?dub=1&sort=0&keyword=${encodeURIComponent(normalizedQuery)}` : `${this.api}/filter?dub=0&sort=0&keyword=${encodeURIComponent(normalizedQuery)}`;\n\n    let data = await this._makeRequest(url);\n\n    if(data.includes(\"Non ci sono anime con i filtri inseriti\")){\n      normalizedQuery = this.addSeasonWordToQuery(normalizedQuery);\n      if(normalizedQuery === \"\") {\n        throw new Error(\"Error encountered while adding Season word to query: \" + query['query']);\n      }\n      url = query['dub'] ? `${this.api}/filter?dub=1&sort=0&keyword=${encodeURIComponent(normalizedQuery)}` : `${this.api}/filter?dub=0&sort=0&keyword=${encodeURIComponent(normalizedQuery)}`;\n      data = await this._makeRequest(url);\n    }\n\n    if(data.includes(\"Non ci sono anime con i filtri inseriti\")){\n      throw new Error(\"No results found\");\n    }\n    \n    const $: DocSelectionFunction = LoadDoc(data);\n\n    const animes: SearchResult[] = [];\n    const validTitles:{title:string; score:number}[] = []; //it contains the ids and score of the valid titles\n\n    $('div.film-list>div.item').each(\n      (index: number, element: DocSelection) => {\n        let aTag = element.find('.name');\n        let id: string = aTag.attr('href') ?? '';\n        let url: string = `${this.api}${id}`;\n        let title: string = aTag.text().trim();\n\n        let titleToCompare: string = title.toLowerCase().replace(/\\s*\\(\\s*ita\\s*\\)\\s*/gi, \"\").trim();\n\n        console.log(titleToCompare);\n\n        try{\n          let bestScore:number | null = filterBySimilarity(titleToCompare, aniListTitlesAndSynonyms, this.threshold);\n          if (bestScore != null) {\n            validTitles.push({title, score: bestScore});\n          }\n        }\n        catch(error){\n          console.error(\"Error: \" + error);\n        }\n\n        let searchResult: SearchResult = {\n          id: id,\n          url: url,\n          title: title,\n          subOrDub: 'both'\n        }\n        animes.push(searchResult);\n      }\n    );\n\n    if(validTitles.length > 0) {\n      let bestMatch = validTitles.reduce((prev, current) => (prev.score > current.score) ? prev : current);\n      let animeToReturn = animes.filter(anime => anime.title.toLowerCase() === bestMatch.title.toLowerCase())[0];\n      if(animeToReturn)\n        return [animeToReturn];\n    }\n    //If no valid title is found, return an error to avoid mismatches\n    throw new Error(\"No results found\");\n  }\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}${id}`;\n\n    const data = await this._makeRequest(url);\n    const $ = LoadDoc(data);\n\n    let episodes = $('div.server.active>ul.episodes>li.episode').map((index, element) => {\n      let aTag = element.find('a');\n      let episodeId = aTag.attr('data-id') ?? \"\";\n      let url = `${this.api}/api/episode/serverPlayerAnimeWorld?id=${episodeId}`;\n      let episodeNumber = aTag.attr('data-episode-num') ?? \"\";\n\n      let episodeDetails: EpisodeDetails = {\n        id: episodeId,\n        url: url,\n        title: `Episodio ${episodeNumber}`,\n        number: Number(index+1)\n      }\n\n      return episodeDetails;\n    })\n\n\n    return episodes;\n  }\n  async findEpisodeServer(\n    episode: EpisodeDetails,\n    _server: string\n  ): Promise<EpisodeServer> {\n    let server = 'AnimeWorld Server';\n    if (_server !== 'default') server = _server;\n\n    const episodeServer: EpisodeServer = {\n      server: server,\n      headers: {\n        Referer: `${this.api}`,\n        Cookie: \"__ddg1_=;__ddg2_=;\",\n        \"Access-Control-Allow-Origin\": \"*\"\n      },\n      videoSources: [],\n    };\n\n    if (episode.url.startsWith('https')) {\n      let [videoUrl, type] = await this.getMp4Url(episode.url);\n\n      episodeServer.videoSources = [\n        {\n          quality: '720p', //I'm not able to find the quality of the video, so I set it to 720p by default\n          subtitles: [],\n          type: type as VideoSourceType,\n          url: videoUrl\n        }\n      ]\n\n      return episodeServer;\n    }\n    throw new Error(\"No server found\");\n\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0',\n        Cookie: \"__ddg1_=;__ddg2_=;\"\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    const body = await response.text();\n    return body;\n  }\n\n  normalizeQuery(query: string): string {\n\n    const extras = [\n      'EXTRA PART',\n      'OVA',\n      'SPECIAL',\n      'RECAP',\n      'FINAL SEASON',\n      'BONUS',\n      'SIDE STORY',\n      'PART\\\\s*\\\\d+',\n      'EPISODE\\\\s*\\\\d+'\n    ];\n\n    const pattern = new RegExp(`\\\\b(${extras.join('|')})\\\\b`, 'gi');\n\n    let normalizedQuery = query\n      .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1') //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n      .replace(/(\\d+)\\s*Season/i, '$1') //Removes season and keeps the number before the Season word\n      .replace(/Season\\s*(\\d+)/i, '$1') //Removes season and keeps the number after the Season word\n      .replace(pattern, '') //Removes extras\n      .replace(/-.*?-/g, '') // Removes -...-\n      .replace(/\\bThe(?=\\s+Movie\\b)/gi, '')\n      .replace(/~/g, ' ') //Removes ~\n      .replace(/\\s+/g, ' ') //Replaces 1+ whitespaces with 1\n      .trim();\n\n    return normalizedQuery;\n  }\n\n\n  addSeasonWordToQuery(query: string): string {\n    if (/Season/i.test(query)) return query;\n    \n    const match = query.match(/\\b(\\d+)(st|nd|rd|th)?\\b/);\n    if (!match || match.index === undefined) return query;\n    return \"\";\n  }\n\n  async getMp4Url(url: string): Promise<string[]> {\n\n    const body = await this._makeRequest(url);\n    const $ = LoadDoc(body);\n\n    let videoTag = $('video>source');\n\n    let videoUrl = videoTag.attr('src') ?? \"\";\n    let type = videoTag.attr('type')?.split('/')[1] ?? \"\";\n\n    return [videoUrl, type];\n\n  }\n\n  getConvertedIndex(mangaChapter: string): number {\n    let chapterNumber = mangaChapter.split('.');\n\n    if(chapterNumber.length > 1) {\n      return Number(chapterNumber[0]) + 1;\n    }\n    return Number(chapterNumber[0]);\n  }\n}\n\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n\n  // Inizializza la prima colonna e riga della matrice\n  for (let i = 0; i <= a.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= b.length; j++) {\n    matrix[0][j] = j;\n  }\n\n  // Calcola la distanza\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,    // Cancellazione\n        matrix[i][j - 1] + 1,    // Inserimento\n        matrix[i - 1][j - 1] + cost // Sostituzione\n      );\n    }\n  }\n\n  return matrix[a.length][b.length];\n}\n\nfunction similarityScore(a: string, b: string): number {\n  const distance = levenshteinDistance(a, b);\n  const maxLen = Math.max(a.length, b.length);\n  if (maxLen === 0) return 1; // Evita divisione per zero\n  return 1 - distance / maxLen;\n}\n\nfunction filterBySimilarity(input: string, candidates: string[], threshold: number): number | null{\n  let validMatches = candidates\n    .map(candidate => ({\n      title: candidate,\n      score: similarityScore(normalizeStringBeforeLevenshtein(input), normalizeStringBeforeLevenshtein(candidate)),\n    }))\n    .filter(item => item.score >= threshold);\n\n  if (validMatches.length > 0) {\n    return validMatches.reduce((prev, current) => (prev.score > current.score) ? prev : current).score;\n  }\n\n  return null;\n    \n}\n\nasync function getAniListMangaDetails(query: string, id: number = 0): Promise<AniListAnimeDetails> {\n  const aniListAPI = 'https://graphql.anilist.co';\n  let variables = {};\n  let aniListQuery = '';\n\n  if (id == 0) {\n    variables = {\n      search: query,\n    };\n    aniListQuery = getAniListQueryString('search');\n  } else {\n    variables = {\n      mediaId: id,\n    };\n    aniListQuery = getAniListQueryString('id');\n  }\n\n  let options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify({\n      query: aniListQuery,\n      variables: variables,\n    }),\n  };\n  let responseGraph = await fetch(aniListAPI, options);\n\n  if (!responseGraph.ok) {\n    throw new Error(\n      `Failed to fetch search results: ${responseGraph.statusText}`\n    );\n  }\n\n  let data: GraphQLResponse = await responseGraph.json();\n  let animeYear = data.data.Media.startDate['year'];\n  let animeSynonyms = data.data.Media.synonyms;\n\n  const titles =[];\n  if (data.data.Media.title.english) {\n    titles.push(data.data.Media.title.english);\n  }\n  if (data.data.Media.title.romaji) {\n    titles.push(data.data.Media.title.romaji);\n  }\n\n  let animeDetails: AniListAnimeDetails = {\n    title: titles,\n    synonyms: animeSynonyms ?? [],\n    year: animeYear,\n  };\n\n  return animeDetails;\n}\n\nfunction getAniListQueryString(type: string): string {\n  let query = `query`;\n\n  switch (type) {\n    case 'id':\n      query += `($mediaId: Int) {\n            Media(id: $mediaId) {`;\n      break;\n    case 'search':\n      query += `($search: String) {\n            Media(search: $search) {`;\n      break;\n  }\n  query += `id\n      title {\n        romaji\n        english\n        native\n      }\n      startDate {\n        day\n        month\n        year\n      }\n      meanScore\n      synonyms\n      updatedAt\n      coverImage {\n        large\n      }\n    }\n    }`;\n  return query;\n}\n\nfunction normalizeStringBeforeLevenshtein(input:string):string{\n  return input.replace(/Season/gi, '').replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1').replace(/\\s+/g, ' ').trim().toLowerCase();\n}\n\ninterface AniListAnimeDetails {\n  title: string[];\n  synonyms: string[];\n  year: number;\n}\n\ninterface GraphQLResponse {\n  data: {\n    Media: {\n      id: number;\n      title: {\n        romaji: string;\n        english: string;\n        native: string;\n      };\n      startDate: {\n        day: number;\n        month: number;\n        year: number;\n      };\n      meanScore: number;\n      synonyms: string[];\n      updatedAt: string;\n      coverImage: {\n        large: string;\n      };\n    };\n  };\n}\n"
}